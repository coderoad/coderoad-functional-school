{
  "project": {
    "title": "Functional School",
    "description": "A trip through functional programming in Javascript."
  },
  "chapters": [
    {
      "title": "Array Methods",
      "pages": [
        {
          "title": "Filter",
          "description": "Array -> Array of items that match a condition",
          "explanation": "You've hacked into the school's computer system, and just in time. The grades are in, but you're not too proud of your performance. That's okay, you have a plan: you're going to create a fake report card.\n\nIt would be great if you could `filter` the scores that your parents will see.\n\n`filter` takes a matching condition function and only returns items that result in true. As an example, look at `isA` below:\n\n```\nfunction isA(x) {\n  return x === 'a';\n}\n```\n\n\nLike all of the methods in this chapter, `filter` is already part of the `Array.prototype`, so you can run it following any array. Each item in the array is passed into the params of the condition function, one by one. [Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).\n\n```\nvar list = ['a', 'b'];\nlist.filter(isA);\n\n// if isA(list[0]), add to output array\n// if isA(list[1]), add to output array\n//\n//> ['a']\n```\n\nIf your data was composed of objects, we could use dot notation to find matches. Checkout `isB` below.\n\n```\nfunction isB(x) {\n  return x.item === 'b'\n}\n\nvar list = [{item: 'a'}, {item: 'b'}];\nlist.filter(isB);\n//> [{item: 'b'}]\n```\n\nWhere were we? Back to filtering our grades.\n\nThere's too much student data in the computer system. We'll have to sort through it. Have a look at an example below:\n\n```\nconsole.log(data[0]);\n//> { course: 'Web Security',\n//    instructor: 'Sue Denim',\n//    name: 'Rebecca Heineman',\n//    score: 93,\n//    grade: 'A' }\n```",
          "tasks": [
            {
              "description": "Write a filter condition function called `isAda` that returns true only if the name matches your name: \"Ada Lovelace\".",
              "tests": [
                "1/01/01-filter"
              ],
              "actions": [
                "open('01-filter.js')",
                "set('/**\n * Data is set as a global. Example:\n * [{\n * \"title\": \"Relational Databases\",\n * \"instructor\": \"Sean Quentin Lewis\",\n * \"name\": \"Ada Lovelace\",\n * \"score\": 91,\n * \"grade\": \"A\"\n * },\n * ...\n * ]\n */\n')",
                "insert('function isAda() {\n  // write condition here\n  // return true if student name\n  // matches \"Ada Lovelace\"\n\n}\n')"
              ]
            },
            {
              "description": "Set `var myData` equal to data matching your name, \"Ada Lovelace\".",
              "tests": [
                "1/01/02-filter"
              ],
              "actions": [
                "insert('// call filter condition here\nvar myData = data.filter();\n\n')"
              ]
            },
            {
              "description": "Write a filter condition called `isGoodGrade` that will filter out any \"D\" or \"F\" grades.",
              "tests": [
                "1/01/03-filter"
              ],
              "actions": [
                "insert('// return true if student \"grade\" is not a \"D\" or \"F\"\nfunction isGoodGrade(student) {\n\n}\n')"
              ]
            },
            {
              "description": "Set `var myBest` to your scores, excluding any grades that are \"D\" or \"F\".",
              "tests": [
                "1/01/04-filter"
              ],
              "actions": [
                "insert('// filter out \"D\"'s and \"F\"'s here\nvar myBest = myData.filter();\n\n')"
              ]
            }
          ]
        },
        {
          "title": "Sort",
          "description": "Array -> sorted Array",
          "explanation": "Your grades are filtered down to your name and good scores - but wouldn't it be better if your best grades were displayed first, at the top? Besides, your parents rarely read anything through.\n\nYou can use the array method `sort` to arrange your data. Let's see how it works.\n\n```js\n['c', 'b', 'a'].sort();\n//> ['a', 'b', 'c']\n\n[3, 2, 1].sort();\n//> [1, 2, 3]\n```\n\nBut what about sorting scores inside of an object?\n\n```js\n[{a: 3}, {a: 1}, {a: 2}].sort();\n//> [{a: 3}, {a: 1}, {a: 2}]\n```\n\nThat didn't work. Instead, you can write a custom `compareScore` function.\n\nA sort function takes two params, and compares the first to the second. It should return values saying where the second value should go in the array:\n\n  * -1 : sort to a lower index (front)\n  * 1 : sort to a higher index (back)\n  * 0 : stay the same\n\nAlright, now time to sort your best grades to the top.",
          "tasks": [
            {
              "description": "Write a sort condition function called `compareScore` that can sort your data by score.",
              "tests": [
                "1/02/01-sort"
              ],
              "actions": [
                "open('02-sort.js')",
                "set('function compareScore(a, b) {\n  switch (true) {\n    case b < a:\n    // it should return 1 if b's score is less than a's\n      return;\n    case b > a:\n    // it should return -1 if b's score is more than a's\n      return;\n    default:\n    // it should return 0 if b has the same score as a\n      return;\n  }\n}\n')"
              ]
            },
            {
              "description": "Set `mySortedGrades` to `myBest` data sorted by `compareScore`",
              "tests": [
                "1/02/01-sort"
              ],
              "actions": [
                "insert('// use the compare function to sort myBest\nvar mySorted = myBest\n')"
              ]
            }
          ]
        },
        {
          "title": "Map",
          "description": "Array -> run a function over each item -> Array",
          "explanation": "You've filtered and sorted our data, but wouldn't it be better if you could just change your grades? You can use the array method `map` to run a function that returns changes to your data.\n\nAs an example, let's look at how you would increment each number in an array.\n\n```\nfunction addOne(num) {\n  return num + 1;\n}\n\nfunction addTwo(num) {\n  return num + 2;\n}\n\n[1, 2, 3].map(addOne);\n//> [2, 3, 4]\n\n[1, 2, 3].map(addOne).map(addTwo);\n//> [4, 5, 6]\n```\n\n`map` is powerful.\n\nThose D & F's would look a lot better if they suddenly became A's.\n\nLet's go back to before we filtered out the bad grades.",
          "tasks": [
            {
              "description": "Make a function `changeGrades` that takes student data and changes any \"D\"s and \"F\"s to \"A\"s.",
              "tests": [
                "1/03/01-map"
              ],
              "actions": [
                "open('03-map.js')",
                "set('// change any student.grade's that are D's or F's into A's\nfunction changeGrades(student) {\n\n}\n')"
              ]
            },
            {
              "description": "Map over the student data with the `changeGrades` function",
              "tests": [
                "1/03/02-map"
              ],
              "actions": [
                "insert('// map over `myData` with the `changeGrades` function\nvar myChanged = myData.map();\n')"
              ]
            },
            {
              "description": "Hold up. An A in Data Science looks way to suspicious. Your parents might catch on.\nInstead, let's go back to myData and increment each score by 12 points.",
              "tests": [
                "1/03/03-map"
              ],
              "actions": [
                "insert('// map over `mySlightlyChanged` with a function `increaseGrades` to increment each score by 12\nvar mySlightlyChanged = myData.map();\n')"
              ]
            },
            {
              "description": "Wait. Now you're getting 105 in Algorithm Design class. Set `mySlightlyFixed` to your scores with a maximum score of 95. That should be less suspicious.",
              "tests": [
                "1/03/04-map"
              ],
              "actions": [
                "insert('// set `mySlightlyFixed` to change any scores over 100 to a score of 95\nvar mySlightlyFixed = mySlightlyChanged.map();\n')"
              ]
            },
            {
              "description": "One more problem. Now the scores don't match the grades. Set `myFixed` as the result of using the `getGrade` function to set grades according to the new scores.",
              "tests": [
                "1/03/05-map"
              ],
              "actions": [
                "insert('function getGrade(score) {\n  switch (true) {\n    case (score >= 90):\n      return \"A\";\n    case (score >= 80):\n      return \"B\";\n    case (score >= 70):\n      return \"C\";\n    case (score >= 60):\n      return \"D\";\n    default:\n      return \"F\";\n  }\n}\n// set `myFixed` to update grades to the new scores\nvar myFixed = mySlightlyChanged.map();\n')"
              ]
            }
          ]
        },
        {
          "title": "forEach",
          "description": "Array -> run a function for each item",
          "explanation": "You've updated your grades, but they're still in an array. It's time to loop over them and log them to the console.\n\n`forEach` has a lot in common with `map`, but the major differences between the two is important to understand the difference between \"functional\" & \"imperative\" programming.\n\n> Imperative programming describes the order of actions\n\n> Functional programming describes the data transformation\n\nFunctional programming is a lot like math. As in math, 1 + 1 always equals 2.\n\nIn the same way, a \"pure\" function will always have the same result from a given input. Input 1, output 2. Every time.\n\n```js\n// a pure function\nfunction addOne(x) {\n  return x + 1;\n}\naddOne(1)\n//> 2\naddOne(1)\n//> 2\n```\n\nA function is \"pure\" if it doesn't change anything outside of its scope. Pure functions are easy to test, reuse and reason about. On the other hand, \"impure\" functions are less predictable.\n\n```js\nvar y = 1;\n// impure function\nfunction increment(x) {\n  y += x;\n  return y;\n}\nincrement(1)\n//> 2\nincrement(1)\n//> 3\n```\n\nIt's good practice to ensure your `map` functions remain pure.\n\nBut `forEach` can be a little more dangerous. Why? Let's have a look.\n\n```js\n[1, 2, 3].map(addOne);\n//> [2, 3, 4]\n//\n[1, 2, 3].forEach(addOne);\n//> undefined\n```\n\nWhat? `undefined`? `forEach` runs a function on each item in the array, and doesn't care what the function returns. The function must make changes, called \"side effects\", to even be noticed.\n\n```js\n// impure function, changes log\nfunction addOneToLog(x) {\n  console.log(x);\n}\n\n[1, 2, 3].forEach(addOneToLog);\n//> 2\n//> 3\n//> 4\n```",
          "tasks": [
            {
              "description": "Use `forEach` to log out your report card to the console",
              "tests": [
                "1/04/01-forEach"
              ],
              "actions": [
                "open('04-forEach.js')",
                "set('function logCourse(course) {\n  console.log(`${course.grade}  ${course.score}  ${course.title}`);\n}\n\n// log your grades to the console\nmyFixed.forEach();\n')"
              ]
            },
            {
              "description": "Run `myFixed.forEach` on a second function called `logCourseWithIndex` which looks like `logCourse` but takes a second parameter called index.",
              "tests": [
                "1/04/02-forEach"
              ],
              "actions": [
                "insert('\nfunction logCourseWithIndex(course, index) {\n  console.log(`${index + 1}  ${course.grade}  ${course.score}  ${course.title}`);\n}\n\n// log your grades to the console with an index\nmyFixed.forEach();\n')"
              ]
            },
            {
              "description": "Where does this second parameter come from? Array methods actually have two extra parameters: the index, and the entire array. Run `myFixed.forEach` with `logCourseWithIndexAndArray`.",
              "tests": [
                "1/04/03-forEach"
              ],
              "actions": [
                "insert('\nfunction logCourseWithIndexAndArray(course, index, array) {\n  console.log(`${index + 1}/${array.length}  ${course.grade}  ${course.score}  ${course.title}`);\n}\n\n// log your grades to the console with an index and array length\nmyFixed.forEach();\n')"
              ]
            },
            {
              "description": "What??? Your data has all disappeared? It seems `myFixed` relies on a chain of methods.\n```js\nmyFixed = students\n    .filter(isAda)\n    .sort(compareScore)\n    .map(increaseScore)\n    .map(getGrade)\n    .forEach(logCourseWithIndexAndArray)\n```\n\nThis is why side-effects are dangerous. Students data must have changed, and now all of your transformations are effected.\n\nSomething strange is going on. In the next step we'll try to `find` your data.",
              "tests": [
                "1/04/04-forEach"
              ]
            }
          ]
        },
        {
          "title": "find",
          "description": "Array -> find an item that matches a condition",
          "explanation": "Somehow your name has disappeared from the computer system. We'll have to `find` a way to get it back.\n\nYou quickly put together a list of other students in class. If someone changed your name, it'll be the name that is not in that list.\n\n`find` works similar to `filter`, but returns only the first match.\n\n```\nvar data = [1, 2, 3, 4, 5, 6];\n\nfunction isEven(num) {\n  return num % 2 === 0;\n}\n\n// returns all matching data to a condition\ndata.filter(isEven);\n//> [2, 4, 6]\n\n// returns the first match\ndata.find(isEven);\n//> [2]\n```\n\nFind is great for performantly matching unique values in data, such as \"id\"'s, or in our case, names.",
          "tasks": [
            {
              "description": "`filter` to students in the class titled \"Web Security\"",
              "tests": [
                "1/05/01-find"
              ],
              "actions": [
                "open('05-find.js')",
                "set('// search for a student with a name\n// not matching students in the list\nvar otherStudents = [\"Albert Gonzalez\", \"Brian Kernaghan\", \"Danielle Bunten Berry\", \"Donald Knuth\", \"Grace Hopper\", \"Hack Kerr\", \"James Gosling\", \"Ken Thompson\", \"Kevin Mitnick\", \"Linus Torvalds\", \"Niklaus Wirth\", \"Rebecca Heineman\", \"Tim Berners-Lee\", \"Xiao Tian\", \"Ying Cracker\"];\n')",
                "insert('\n// filter for students.title is \"Web Security\"\nvar myClass = students\n')"
              ]
            },
            {
              "description": "`find` the name in `myClass` that isn't in the list of known students",
              "tests": [
                "1/05/02-find"
              ],
              "actions": [
                "insert('\n// hint: use `indexOf` to find if an item is in the array\nvar unknownStudent  \n')"
              ]
            },
            {
              "description": "`filter` down to students without known names",
              "tests": [
                "1/05/03-find"
              ],
              "actions": [
                "insert('var unknownStudentList\n')"
              ]
            },
            {
              "description": "`map` over the result to get only the `name` property",
              "tests": [
                "1/05/04-find"
              ],
              "actions": [
                "insert('var unknownStudentNames\n')"
              ]
            },
            {
              "description": "`join('')` the array of names to output result\n\n# concat\nArray + Array -> Array\n\nBefore we've been working on a structured set of student data.\n\n```js\n// array of students\n[\n  {\n  \"title\": \"Relational Databases\",\n  \"instructor\": \"Sean Quentin Lewis\",\n  \"name\": \"Rebecca Heineman\",\n  \"score\": 71,\n  \"grade\": \"C\"\n  }\n// students in courses...\n]\n```\n\nTo be safe, let's now work on the original data set. Notice how it is structured differently.\n\n```js\n// array of courses\n[\n  {\n    \"title\": \"Relational Databases\",\n    \"instructor\": \"Sean Quentin Lewis\",\n    \"students\": [\n      {\n        \"name\": \"Rebecca Heineman\",\n        \"score\": 71,\n        \"grade\": \"C\"\n      }\n    // students...\n    ]\n  }\n  // courses...\n]\n```\n\nIn this data set, there is an array of students within an array of courses. So how can we recreate our original array of students from the courses? We can use `concat`.\n\nWeird things happen when you start combining arrays. `concat` brings sanity.\n\n```js\n[1, 2] + [3, 4];\n//> \"1, 23, 4\"\n\n[1, 2].push([3, 4]);\n//> 3\n\n[1, 2].join([3, 4]);\n//> \"13, 42\"\n\n[1, 2].concat([3, 4]);\n//> [1, 2, 3, 4]\n```\n\nUnfortunately, Javascript is missing a built in array method to concat multiple arrays together: let's call it `flatten` (often called `concatAll`). `flatten` should loop over an array and concat each element.\n\n```js\nvar start = [{\n  a: 1,\n  c: [\n    { b: 1 }\n  ]\n}, {\n  a: 2,\n  c: [\n    { b: 2 }, { b: 3 }\n  ]\n}];\n\nvar middle = start.map(function(outer) {\n  return outer.c.map(function(inner) {\n    return {\n      a: outer.a,\n      b: inner.b\n    };\n  });\n});\n//> [ [{ a: 1, b: 1 }], [{a: 2, b: 2}, {a: 2, b: 3}] ]\n\nvar end = pre.flatten();\n//> [{a: 1, b: 1}, {a: 2, b: 2}, {a: 2, b: 3}]\n```\n\nBack to business.\n\nWe have a suspect in mind: a classmate named \"Hack Kerr\". He's a nice guy, and he's always been friendly to you - but there's something suspicious about him: his name.\n\nFirst let's recreate our student array of data from the course data.",
              "tests": [
                "1/05/05-find"
              ],
              "actions": [
                "insert('var decodedName\n')"
              ]
            },
            {
              "description": "First, test out `flatten` on the `flattenedArray`\n@open('06-concat.js')",
              "tests": [
                "1/06/01-concat"
              ],
              "hints": [
                "js\nvar start = [{\n  a: 1,\n  c: [\n    { b: 1 }\n  ]\n}, {\n  a: 2,\n  c: [\n    { b: 2 }, { b: 3 }\n  ]\n}];\n\nvar middle = start.map(function(outer) {\n  return outer.c.map(function(inner) {\n    return {\n      a: outer.a,\n      b: inner.b\n    };\n  });\n});\n//> [ [{ a: 1, b: 1 }], [{a: 2, b: 2}, {a: 2, b: 3}] ]",
                "Flatten the resulting arrays",
                "js\nvar end = pre.flatten();\n//> [{a: 1, b: 1}, {a: 2, b: 2}, {a: 2, b: 3}]"
              ],
              "actions": [
                "set('`\n// Array.prototype can be used to create new Array methods\nArray.prototype.flatten = function() {\n  // more on `reduce` coming up next\n  return this.reduce(function(a, b) {\n    return a.concat(b);\n  }, []);\n});')",
                "insert('\n// use `flatten` on `numberedList` to set flattenedArray to [1, 2, 3, 4]\nvar numberedList = [[1, 2], [3, 4]]\nvar flattenedArray;\n')"
              ]
            },
            {
              "description": "Map over the course data array, and map over the student array inside of the course data. Set `doubleArray` to return an array of array of objects that looks like this:\n\n```js\n  {\n  \"title\": \"Relational Databases\",\n  \"instructor\": \"Sean Quentin Lewis\",\n  \"name\": \"Rebecca Heineman\",\n  \"score\": 71,\n  \"grade\": \"C\"\n  }\n```",
              "tests": [
                "1/06/02-concat"
              ],
              "actions": [
                "insert('\n// map over doubleArray twice\nvar doubleArray = courses;\n')"
              ]
            },
            {
              "description": "Use `flatten` to put all data into a single array. Set `students` to the result.",
              "tests": [
                "1/06/03-concat"
              ],
              "actions": [
                "insert('\n// flatten doubleArray\nvar students = doubleArray;\n')"
              ]
            },
            {
              "description": "Use the `suspects` array to `filter` to only \"Hack Kerr\"'s data",
              "tests": [
                "1/06/04-concat"
              ],
              "actions": [
                "insert('\nvar suspects = [\"Hack Kerr\"];\n\n// filter to data matching `suspects`\nvar suspectData = students;\n')"
              ]
            },
            {
              "description": "You just thought of two more suspects!  `concat` the new suspects array onto the `suspects` list.",
              "tests": [
                "1/06/05-concat"
              ],
              "actions": [
                "insert('\nvar newSuspects = [\"Kevin Mitnick\", \"Albert Gonzalez\"];\n')"
              ]
            }
          ]
        },
        {
          "title": "reduce",
          "description": "Array -> transform into anything",
          "explanation": "```js\nfunction add(prev, curr) {\n    console.log(`add(${prev}, ${curr}) -> ${prev + curr}`)\n    return prev + curr;\n}\n\n[1, 5, 10].reduce(add, 100); // initial value\n\n// add(100, 1) -> 101\n// add(101, 5) -> 106\n// add(106, 10) -> 116\n//> 116\n```",
          "tasks": [
            {
              "description": "Use `reduce` to sum the numbers in the `practice` array",
              "tests": [
                "1/07/01-reduce"
              ],
              "actions": [
                "open('07-reduce.js')",
                "set('var practice = [1, 1, 2, 3, 5, 8, 13, 21];\n\n// total the numbers using a reduce function\n// hint: start at 0\nvar total = practice.reduce();\n')"
              ]
            },
            {
              "description": "`map` over each course and use `reduce` to calculate the class averages for each class. Set `averages` to the resulting array of all class averages.",
              "tests": [
                "1/07/02-reduce"
              ],
              "actions": [
                "insert('// Remember, an average is the sum of all student scores divided by the number of students\n// set the result to an array, for example: [50, 65, 75, 85, ...];\nvar averages = courses.reduce();\n')"
              ]
            },
            {
              "description": "`reduce` to an array of suspect scores",
              "tests": [
                "1/07/03-reduce"
              ],
              "actions": [
                "insert('\n// [{ name: 'suspectName', scores: [ 50, 65, 75, 85...] }, ... ]\nvar suspectScores = courses.reduce();\n')"
              ]
            },
            {
              "description": "`map` over suspect data to find the `\"difference\"` from subtracting the students score from the average score. Add this to `suspectScores` using the key `difference`. The resulting array should look like this:\n```js\n[{\n  name: 'suspectName',\n  scores: [50, 65, 75, 85...],\n  difference: 15\n}]\n```",
              "tests": [
                "1/07/04-reduce"
              ]
            },
            {
              "description": "`reduce` down to any likely suspect names by filtering with the `isCheater` function",
              "tests": [
                "1/07/05-reduce"
              ],
              "actions": [
                "insert('\nfunction isCheater(suspect) {\n  return suspect.difference > 200;\n}\n\n// reduce down to a string of likely suspects\nvar likelySuspect = suspectScores.reduce().join(', ');\nconsole.log(likelySuspect);\n')"
              ]
            }
          ]
        }
      ],
      "description": "Using common built-in Javascript array methods such as `map` & `reduce`.\n\nBy the end, you should have an understanding of how to use array methods to manipulate semi-complex data.\n\n<!-- @import('./tutorial/1/08/challenge-1') -->\n<!-- @import('./tutorial/1/09/challenge-2') -->"
    }
  ]
}